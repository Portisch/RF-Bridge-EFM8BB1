//=========================================================
// src/RF_Bridge_2_main.c: generated by Hardware Configurator
//
// This file will be updated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!!
//=========================================================

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <SI_EFM8BB1_Register_Enums.h>                  // SFR declarations
#include "Globals.h"
#include "InitDevice.h"
#include "uart_0.h"
#include "pca_0.h"
#include "wdt_0.h"
#include "uart.h"
#include "RF_Handling.h"
#include "RF_Protocols.h"
// $[Generated Includes]
// [Generated Includes]$

//-----------------------------------------------------------------------------
// SiLabs_Startup() Routine
// ----------------------------------------------------------------------------
// This function is called immediately after reset, before the initialization
// code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
// useful place to disable the watchdog timer, which is enable by default
// and may trigger before main() in some instances.
//-----------------------------------------------------------------------------
void SiLabs_Startup (void)
{

}

SI_SEGMENT_VARIABLE(ReadUARTData, bool, SI_SEG_DATA) = true;

void finish_command(uint8_t command)
{
	// send uart command
	uart_put_command(command);

	// enable UART again
	ReadUARTData = true;

	// restart sniffing in its previous mode
	PCA0_DoSniffing(last_sniffing_command);
}

//-----------------------------------------------------------------------------
// main() Routine
// ----------------------------------------------------------------------------
int main (void)
{
	SI_SEGMENT_VARIABLE(last_sniffing_mode, rf_sniffing_mode_t, SI_SEG_XDATA);
	SI_SEGMENT_VARIABLE(tr_repeats, uint8_t, SI_SEG_XDATA);
	SI_SEGMENT_VARIABLE(l, uint16_t, SI_SEG_XDATA);
	SI_SEGMENT_VARIABLE(bucket, uint16_t, SI_SEG_XDATA);

	// Call hardware initialization routine
	enter_DefaultMode_from_RESET();

	// enter default state
	LED = LED_OFF;
	BUZZER = BUZZER_OFF;
	T_DATA = TDATA_OFF;

	// enable UART
	UART0_init(UART0_RX_ENABLE, UART0_WIDTH_8, UART0_MULTIPROC_DISABLE);

	// start sniffing if enabled by default
#if Sniffing_On == 1
	// set desired sniffing type to PT2260
	sniffing_mode = STANDARD;
	PCA0_DoSniffing(RF_CODE_RFIN);
	last_sniffing_command = RF_CODE_RFIN;
#else
	PCA0_StopSniffing();
#endif

	// enable global interrupts
	IE_EA = 1;

	for (l = 0; l < 10000; l++)
		BUZZER = BUZZER_ON;

	BUZZER = BUZZER_OFF;

	while (1)
	{
		unsigned int rxdata;
		uint8_t len;
		uint8_t position;

		/* reset Watch Dog Timer */
		WDT0_feed();

		/*------------------------------------------
		 * check if something got received by UART
		 ------------------------------------------*/
		// read only data from uart if idle
		if (ReadUARTData)
			rxdata = uart_getc();
		else
			rxdata = UART_NO_DATA;

		if (rxdata == UART_NO_DATA)
		{
			if (uart_state == IDLE)
				l = 0;
			else
			{
				if (++l > 10000)
					BUZZER = BUZZER_ON;

				if (l > 30000)
				{
					l = 0;
					uart_state = IDLE;
					uart_command = NONE;
					BUZZER = BUZZER_OFF;
				}
			}
		}
		else
		{
			l = 0;

			// state machine for UART
			switch(uart_state)
			{
				// check if UART_SYNC_INIT got received
				case IDLE:
					if ((rxdata & 0xFF) == RF_CODE_START)
						uart_state = SYNC_INIT;
					break;

				// sync byte got received, read command
				case SYNC_INIT:
					uart_command = rxdata & 0xFF;
					uart_state = SYNC_FINISH;

					// check if some data needs to be received
					switch(uart_command)
					{
						case RF_CODE_LEARN:
							InitTimer3_ms(1, 50);
							BUZZER = BUZZER_ON;
							// wait until timer has finished
							WaitTimer3Finished();
							BUZZER = BUZZER_OFF;

							// set desired RF protocol PT2260
							sniffing_mode = STANDARD;
							last_sniffing_command = PCA0_DoSniffing(RF_CODE_LEARN);

							// start timeout timer
							InitTimer3_ms(1, 30000);
							break;
						case RF_CODE_RFOUT:
							// stop sniffing while handling received data
							PCA0_StopSniffing();
							uart_state = RECEIVING;
							tr_repeats = RF_TRANSMIT_REPEATS;
							position = 0;
							len = 9;
							break;
						case RF_DO_BEEP:
							// stop sniffing while handling received data
							PCA0_StopSniffing();
							uart_state = RECEIVING;
							position = 0;
							len = 2;
							break;
						case RF_ALTERNATIVE_FIRMWARE:
							break;
						case RF_CODE_SNIFFING_ON:
							sniffing_mode = ADVANCED;
							PCA0_DoSniffing(RF_CODE_SNIFFING_ON);
							last_sniffing_command = RF_CODE_SNIFFING_ON;
							break;
						case RF_CODE_SNIFFING_OFF:
							// set desired RF protocol PT2260
							sniffing_mode = STANDARD;
							// re-enable default RF_CODE_RFIN sniffing
							PCA0_DoSniffing(RF_CODE_RFIN);
							last_sniffing_command = RF_CODE_RFIN;
							break;
						case RF_CODE_RFOUT_NEW:
							tr_repeats = RF_TRANSMIT_REPEATS;
							/* no break */
						case RF_CODE_RFOUT_BUCKET:
							uart_state = RECEIVE_LEN;
							break;
						case RF_CODE_SNIFFING_ON_BUCKET:
							last_sniffing_command = PCA0_DoSniffing(RF_CODE_SNIFFING_ON_BUCKET);
							break;
						case RF_CODE_LEARN_NEW:
							InitTimer3_ms(1, 50);
							BUZZER = BUZZER_ON;
							// wait until timer has finished
							WaitTimer3Finished();
							BUZZER = BUZZER_OFF;

							// enable sniffing for all known protocols
							last_sniffing_mode = sniffing_mode;
							sniffing_mode = ADVANCED;
							last_sniffing_command = PCA0_DoSniffing(RF_CODE_LEARN_NEW);

							// start timeout timer
							InitTimer3_ms(1, 30000);
							break;
						case RF_CODE_ACK:
							// re-enable default RF_CODE_RFIN sniffing
							last_sniffing_command = PCA0_DoSniffing(last_sniffing_command);
							uart_state = IDLE;
							break;

						// unknown command
						default:
							uart_command = NONE;
							uart_state = IDLE;
							break;
					}
					break;

				// Receiving UART data length
				case RECEIVE_LEN:
					position = 0;
					len = rxdata & 0xFF;
					if (len > 0)
					{
						// stop sniffing while handling received data
						PCA0_StopSniffing();
						uart_state = RECEIVING;
					}
					else
						uart_state = SYNC_FINISH;
					break;

				// Receiving UART data
				case RECEIVING:
					RF_DATA[position] = rxdata & 0xFF;
					position++;

					if (position == len)
					{
						uart_state = SYNC_FINISH;
					}
					else if (position >= RF_DATA_BUFFERSIZE)
					{
						len = RF_DATA_BUFFERSIZE;
						uart_state = SYNC_FINISH;
					}
					break;

				// wait and check for UART_SYNC_END
				case SYNC_FINISH:
					if ((rxdata & 0xFF) == RF_CODE_STOP)
					{
						uart_state = IDLE;
						ReadUARTData = false;

						// check if AKN should be sent
						switch(uart_command)
						{
							case RF_CODE_LEARN:
							case RF_CODE_SNIFFING_ON:
							case RF_CODE_SNIFFING_OFF:
							case RF_CODE_RFIN:
							case RF_CODE_SNIFFING_ON_BUCKET:
								// send acknowledge
								uart_put_command(RF_CODE_ACK);
							case RF_CODE_ACK:
								// enable UART again
								ReadUARTData = true;
								break;
							case RF_CODE_RFOUT_BUCKET:
								tr_repeats = RF_DATA[1] + 1;
								break;
						}
					}
					break;
			}
		}

		/*------------------------------------------
		 * check command byte
		 ------------------------------------------*/
		switch(uart_command)
		{
			// do original learning, new RF code learning
			case RF_CODE_LEARN:
			case RF_CODE_LEARN_NEW:

				// check if a RF signal got decoded
				if ((RF_DATA_STATUS & RF_DATA_RECEIVED_MASK) != 0)
				{
					InitTimer3_ms(1, 200);
					BUZZER = BUZZER_ON;
					// wait until timer has finished
					WaitTimer3Finished();
					BUZZER = BUZZER_OFF;

					switch(uart_command)
					{
						case RF_CODE_LEARN:
							PCA0_DoSniffing(last_sniffing_command);
							uart_put_RF_Data_Standard(RF_CODE_LEARN_OK);
							break;

						case RF_CODE_LEARN_NEW:
							sniffing_mode = last_sniffing_mode;
							PCA0_DoSniffing(last_sniffing_command);
							uart_put_RF_Data_Advanced(RF_CODE_LEARN_OK_NEW, RF_DATA_STATUS & 0x7F);
							break;
					}

					// clear RF status
					RF_DATA_STATUS = 0;

					// enable interrupt for RF receiving
					PCA0CPM0 |= PCA0CPM0_ECCF__ENABLED;

					// enable UART again
					ReadUARTData = true;
				}
				// check for learning timeout
				else if (IsTimer3Finished())
				{
					InitTimer3_ms(1, 1000);
					BUZZER = BUZZER_ON;
					// wait until timer has finished
					WaitTimer3Finished();
					BUZZER = BUZZER_OFF;

					// send not-acknowledge
					switch(uart_command)
					{
						case RF_CODE_LEARN:
							finish_command(RF_CODE_LEARN_KO);
							break;

						case RF_CODE_LEARN_NEW:
							finish_command(RF_CODE_LEARN_KO_NEW);
							break;
					}
				}
				else
				{
					// handle new received buckets
					if (buffer_out(&bucket))
						HandleRFBucket(bucket & 0x7FFF, (bool)((bucket & 0x8000) >> 15));
				}
				break;

			// do original sniffing
			case RF_CODE_RFIN:
			case RF_CODE_SNIFFING_ON:

				// check if a RF signal got decoded
				if ((RF_DATA_STATUS & RF_DATA_RECEIVED_MASK) != 0)
				{
					switch(uart_command)
					{
						case RF_CODE_RFIN:
							uart_put_RF_Data_Standard(RF_CODE_RFIN);
							break;

						case RF_CODE_SNIFFING_ON:
							uart_put_RF_Data_Advanced(RF_CODE_SNIFFING_ON, RF_DATA_STATUS & 0x7F);
							break;
					}

					// clear RF status
					RF_DATA_STATUS = 0;

					// enable interrupt for RF receiving
					PCA0CPM0 |= PCA0CPM0_ECCF__ENABLED;
				}
				else
				{
					// handle new received buckets
					if (buffer_out(&bucket))
						HandleRFBucket(bucket & 0x7FFF, (bool)((bucket & 0x8000) >> 15));
				}
				break;

			// do original transfer
			case RF_CODE_RFOUT:
				// only do the job if all data got received by UART
				if (uart_state != IDLE)
					break;

				// do transmit of the data
				switch(rf_state)
				{
					// init and start RF transmit
					case RF_IDLE:
						tr_repeats--;
						PCA0_StopSniffing();

						// byte 0..1:	Tsyn
						// byte 2..3:	Tlow
						// byte 4..5:	Thigh
						// byte 6..7:	24bit Data

						buckets[0] = *(uint16_t *)&RF_DATA[2];
						buckets[1] = *(uint16_t *)&RF_DATA[4];
						buckets[2] = *(uint16_t *)&RF_DATA[0];

						SendBuckets(
								buckets, PROTOCOL_DATA[0].pulses.size,
								PROTOCOL_DATA[0].start.dat, PROTOCOL_DATA[0].start.size,
								PROTOCOL_DATA[0].bit0.dat, PROTOCOL_DATA[0].bit0.size,
								PROTOCOL_DATA[0].bit1.dat, PROTOCOL_DATA[0].bit1.size,
								PROTOCOL_DATA[0].bit_count,
								PROTOCOL_DATA[0].inverse,
								&RF_DATA[6]
								);
						break;

					// wait until data got transfered
					case RF_FINISHED:
						if (tr_repeats == 0)
						{
							// disable RF transmit
							T_DATA = TDATA_OFF;

							finish_command(RF_CODE_ACK);
						}
						else
							rf_state = RF_IDLE;
						break;
				}
				break;

			// do a beep
			case RF_DO_BEEP:
				// only do the job if all data got received by UART
				if (uart_state != IDLE)
					break;

				InitTimer3_ms(1, *(uint16_t *)&RF_DATA[0]);
				BUZZER = BUZZER_ON;
				// wait until timer has finished
				WaitTimer3Finished();
				BUZZER = BUZZER_OFF;

				// send acknowledge
				finish_command(RF_CODE_ACK);
				break;

			// host was requesting the firmware version
			case RF_ALTERNATIVE_FIRMWARE:

				// send firmware version
				finish_command(FIRMWARE_VERSION);
				break;

			// transmit data on RF
			case RF_CODE_RFOUT_NEW:
				// only do the job if all data got received by UART
				if (uart_state != IDLE)
					break;

				// do transmit of the data
				switch(rf_state)
				{
					// init and start RF transmit
					case RF_IDLE:
						tr_repeats--;
						PCA0_StopSniffing();

						// byte 0:		PROTOCOL_DATA index
						// byte 1..:	Data

						SendBucketsByIndex(RF_DATA[0], &RF_DATA[1]);
						break;

					// wait until data got transfered
					case RF_FINISHED:
						if (tr_repeats == 0)
						{
							// disable RF transmit
							T_DATA = TDATA_OFF;

							// send acknowledge
							finish_command(RF_CODE_ACK);
						}
						else
						{
							rf_state = RF_IDLE;
						}
						break;
				}
				break;

			case RF_CODE_RFOUT_BUCKET:
			{
				// only do the job if all data got received by UART
				if (uart_state != IDLE)
					break;

				// do transmit of the data
				switch(rf_state)
				{
					// init and start RF transmit
					case RF_IDLE:
						tr_repeats--;
						PCA0_StopSniffing();

						// byte 0:				number of buckets: k
						// byte 1:				number of repeats: r
						// byte 2*(1..k):		bucket time high
						// byte 2*(1..k)+1:		bucket time low
						// byte 2*k+2..N:		RF buckets to send
						SendRFBuckets((uint16_t *)RF_DATA[2], &RF_DATA[2 + RF_DATA[0] * 2], len - 2 - RF_DATA[0] * 2);
						break;

					// wait until data got transfered
					case RF_FINISHED:
						if (tr_repeats == 0)
						{
							// disable RF transmit
							T_DATA = TDATA_OFF;

							// send acknowledge
							finish_command(RF_CODE_ACK);
						}
						else
						{
							rf_state = RF_IDLE;
						}
						break;
				}
				break;
			}
		case RF_CODE_SNIFFING_ON_BUCKET:

			// check if a RF signal got decoded
			if ((RF_DATA_STATUS & RF_DATA_RECEIVED_MASK) != 0)
			{
				uart_put_RF_buckets(RF_CODE_SNIFFING_ON_BUCKET);

				// clear RF status
				RF_DATA_STATUS = 0;

				// enable interrupt for RF receiving
				PCA0CPM0 |= PCA0CPM0_ECCF__ENABLED;
			}
			else
			{
				// do bucket sniffing handling
				if (buffer_out(&bucket))
					Bucket_Received(bucket & 0x7FFF, (bool)((bucket & 0x8000) >> 15));
			}

			break;
		} //switch(uart_command)
	} //while (1)
}
